# 小满的miniCPU设计实验报告
虽然有ai帮助但都还是自己亲手补完的minicpu🤩
## 💻简要介绍
## 🧐环境配置
## 😭cpu结构设计, 代码补全
## 🤓vivado生灌
## 🤪程序测试仿真
## 🤩想跟学长学姐说的话
## 1.💻简要介绍
像🍐学长说的一样, cpu真的是一个比较考验理解能力, 对**项目整体化结构**的理解有很大要求的一个赛道, 在刚接触时我因为什么都不了解所以问了ai, 跟ai做了两天无果, 因为都是懵的状态, 看了🍐学长留的小零食才对cpu有了一些理解, 也知道了到底该如何使用vivado和题目中的文件都是什么意思, 后来就是改代码对接口灌文件了，可能没做完但我已经尽力而为了，这段时间很忙，但我也在尽力学，这跟报告和我的代码可能有些不足但也是我最终的答卷。
## 2.🧐环境配置
其实这一步并不难，主要就是这几个步骤：  
(1)下载vivado2023.2(第一次在虚拟机里下载了最后发现跑不动🤬).  
(2)在Ubuntu里下载好 loongarch32r-linux-gnusf 交叉编译工具链.
 ![图1](./images/p1.png)  
(3)存器链传递程序的源汇编代码后面用。 
 ![图2](./images/p2.png)  
 os: 其实这部分我就做了挺久, 因为之前属于完完全全的电脑小白, 连虚拟机, Ubuntu这些东西都不知道, 更别说使用他了, 在这个过程中我了解到了很多, 比如Ubuntu命令行的简单使用, 镜像站，挂载使用共享文件夹什么的，开辟了我对计算机的新认识吧。不过顺利完成了，也学到了东西，就挺好。😋
## 3.😭cpu结构设计, 代码补全
其实这一块, 嗯说实话应该是我最没发言权的地方了, 因为确实代码是让ai生成的, 自己只调了调接口什么的, 结构设计的话, 我学了cpu简单原理之后按自己理解画了一张图
![图3](./images/p3.jpg)
还有设计理由
1. ***PC(Program Counter)***
功能：保存当前指令地址；每个时钟周期更新为  next_pc (pc+4 或分支目标)。
设计理由：它是整条流水线的“地址源头”，与存储器直接对接，且次态逻辑多路选择，独立成模块后时序清晰，也方便以后改成 PC+预测或异常向量。
1. ***Instr-Memory(指令 SRAM)***
功能：异步只读，地址输入  pc ，输出 32-bit 指令字。
设计理由：物理上在现代 SoC 里就是独立 SRAM/Cache,接口只有“地址入-数据出”，与数据口完全分离，画成单独方块可体现哈佛结构雏形。
1. ***Decoder(指令译码单元)***
功能：把 32-bit 指令切片成  opcode/ra/rb/rd/imm16  并做符号扩展，同时生成全部控制信号（ RegWrite/MemWrite/Branch/ALUop/WBsel  等）。
设计理由：所有“位段提取+立即数变形”集中在一处，后面各模块只看“语义级”信号，图面干净；若以后改指令集，只动 Decoder 即可。
1. ***RegFile(32*32 寄存器堆)***
功能: 两读端口(ra、rb 地址输出数据)、一写端口(rd 地址写入 wdata)，写使能受  RegWrite  控制；寄存器 0 恒为 0。
设计理由：它是 CPU 里唯一的“通用状态存储”，与存储器并列；三端口单独画框可清晰体现“数据通路瓶颈”，也方便以后加寄存器窗口或重命名。
1. ***ALU(Arithmetic Logic Unit)***
功能：根据  ALUop  完成加/比较/地址计算，输出 32-bit 结果并生成 Zero 标志供分支使用。
设计理由：纯组合逻辑、功能单一，是数据通路的“运算枢纽”；单独成模块后，关键路径一目了然，也方便以后扩展移位、乘除单元。
1. ***Data-Memory(数据 SRAM)***
功能：按字节/字写使能，地址来自 ALU 结果，写数据来自  rd2_val ，读数据送回写回级。
设计理由：与指令口物理分离，接口信号完整（地址/数据/写使能）,独立画框可体现“load/store 架构”；后期加 Cache 时直接替换该方块即可。
1. ***Branch-Address-Generate***
功能：将符号扩展后的偏移量左移 2 位再与 PC+4 相加，生成分支目标地址。
设计理由：地址计算与 ALU“数据运算”语义不同,单独拉出一个小方块,能让 Next-PC-Mux 的输入箭头更清晰；后期加 JAL/JALR 时把第二个加法器也放这里。
1. ***Next-PC-Mux(三选一多路器)***
功能：在  pc+4 / branch_target / 异常向量  之间选择下一周期 PC。
设计理由：它是 CPU 唯一“控制流切换点”，把所有修改 PC 的源头汇总到一个 Mux,图面只有一条反馈箭头回 PC,易读易验证。
1. ***Write-Back-Mux(三选一多路器)***
功能：在  ALU 结果 / 存储器读数据 / pc+4(JAL 用)  之间选择最终写回寄存器的数据。
设计理由：把“回写数据源”集中，避免在 RegFile 上拉三条 32-bit 总线；后期加 CSR、浮点单元时继续扩展选择端即可。
1.  ***Control-Unit(硬布线控制器)***
功能：以  opcode  为输入，输出全部 1-bit/2-bit 控制信号（ RegWrite/MemWrite/Branch/ALUop/WBsel  等）。
设计理由：所有“控制”与“数据”分离，图面上从该方块拉出孔雀开屏式控制线，老师一眼能看出“谁控制谁”；后期改微码或加流水线时，只动这里。
1.  ***监控/调试模块（非硬件必须，但代码里存在）***
功能: 周期计数、寄存器快照、Fibonacci 模式检测、未知指令报警。
设计理由：虽不参与真实数据通路，却是你验证 Fibonacci 跑通的“眼睛”, 在报告里可列为“Debug-Module”, 体现设计可观测性
没错还是ai😘但我会在面试之前努力把原理看懂的🤓如果你想在这里看我的代码直接点这个:[请来看一看我简陋的小仓库](https://github.com/jiyiweigu/2025_Autumn_CPU_designing.git)
## 4.🤓vivado生灌
这一步看🍐学长留下的小零食其实就很容易理解了, 感谢学长喂饭, 只要把补好的源文件, 测试文件, 约束文件看明白一一对应灌进vivado就好。
## 5.🤪程序测试仿真
重头戏来了, 为了这个波形图我真是没日没夜的调试运行, 在调试Fibonacci数列程序的时候我遇到的问题就是每次虽然pc递增4但是只会输出一个数值, 后来才发现是因为  
**soc_mini_top.b==文件里的assign cpu_data_rdata = (cpu_data_addr == 12'd1024) ? {24'b0, ~switch[7:0]} : 32'b0;**  
这个代码使得cpu_data_rdata只在地址1024的时候返回数据, 哎哟是我错了还是~~老登真这么坏~~。  
![图4](./images/p4.png)
![图5](./images/p5.png)
**pc递增图和输出数据图**(其实我也不知道这能不能证明我跑成功了但我只截了这么点😭)。

下一步就是reg链程序测试, 我当时憨了, 只换了ip核没换tb文件, 一下子跑通了但我觉得不对劲问了ai, ai说没换tb文件也行, 再加上太忙了我就放那了  
下面是我存的一些数据和图  
**最终Fibonacci数列状态:
  r         14 = 00000005 (5)
$finish called at time : 60075 ns : File "D:/minicpu_fibonacci/minicpu_fibonacci.srcs/sources_1/imports/Fibonacci/miniCPU/minicpu_top.v" Line 186
Time 10 ns: PC = c0001f48
Time             60085000: PC = c0001f4c, Instruction = 5c002e20
Time 20 ns: PC = c0001f4c
Time             60095000: PC = c0001f4c, Instruction = 5c002e20**  
![图6](./images/p6.png)
至于没什么波形图是因为，我看不懂😭😭😭.   
 这一部分也学到了很多，==文件路径对齐==， ==接口对齐==， ==对项目的整体的把握==， 不光是像之前写的题一样不用考虑那么多, 只考虑单个程序的运行就好， 而cpu多模块连接的时候要考虑的问题就是我这次学到最重要的地方, 至于**Ubuntu命令行**, **Verilog语法**, **cpu原理**, 环境配置这些也为我以后做项目什么的话打下了基础, 还有这个简单的**markdown语法**, 各种新软件的使用, 确实使我受益匪浅.
### 6.🤩想跟学长学姐说的话
今天离考核结束还剩两天, 但我真的没什么时间精力去实操了,我接下来就要马不停蹄的搞其他事和学代码, 学cpu原理这些理论的东西了,希望面试可以回答出来几个学长学姐的问题就好，这次考核劳累而又充实，真的是带我度过了一个完完全全的电脑小白的时期，不管过没过考核我都很感谢这次经历，我也会更加努力的去继续学习拓展，我第一次自己写实验报告，写的有点像跟学长学姐对话一样，希望学长学姐能多多包容，辛苦学长学姐看我的实验报告了😀  
最后还要特别鸣谢群里的大家们, 尤其是==奶龙==和==梨学长==, 他们给了我很多帮助😘, 我的答卷里也有他们的一份.
